# 集团级API网关系统架构设计文档

## 一、架构设计原则

### 1.1 设计原则
- **高可用性**：消除单点故障，支持故障自愈和降级
- **高性能**：采用异步非阻塞架构，支持高并发场景
- **可扩展性**：支持水平扩展和插件化扩展
- **安全性**：多层次安全防护，满足合规要求
- **可观测性**：全链路监控，问题快速定位
- **开放性**：开放API接口，便于第三方集成

### 1.2 架构风格
- 微服务架构：服务拆分独立部署
- 事件驱动架构：异步处理提升性能
- 插件化架构：支持动态扩展
- 云原生架构：容器化部署和运维

## 二、系统总体架构

### 2.1 架构分层设计

```
┌─────────────────────────────────────────────────────────────────┐
│                        展示层 (Presentation Layer)               │
│  ┌─────────────────┐        ┌─────────────────┐                 │
│  │   Web管理控制台   │        │   开发者门户     │                 │
│  │   (Vue3+Element)│        │   (API文档+调试) │                 │
│  └─────────────────┘        └─────────────────┘                 │
└─────────────────────────────┬───────────────────────────────────┘
                              │
┌─────────────────────────────┴───────────────────────────────────┐
│                        应用层 (Application Layer)               │
│  ┌─────────────────┐        ┌─────────────────┐                 │
│  │   网关服务集群     │        │   管理服务集群     │                 │
│  │  (Spring Gateway)│        │ (Spring Boot Admin)│               │
│  └─────────────────┘        └─────────────────┘                 │
└─────────────────────────────┬───────────────────────────────────┘
                              │
┌─────────────────────────────┴───────────────────────────────────┐
│                        服务层 (Service Layer)                   │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐            │
│  │API管理服务│  │认证授权服务│  │流量控制服务│  │监控告警服务│            │
│  │Service  │  │Service  │  │Service  │  │Service  │            │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘            │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐            │
│  │配置管理服务│  │日志分析服务│  │插件管理服务│  │租户管理服务│            │
│  │Service  │  │Service  │  │Service  │  │Service  │            │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘            │
└─────────────────────────────┬───────────────────────────────────┘
                              │
┌─────────────────────────────┴───────────────────────────────────┐
│                        数据层 (Data Layer)                      │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐            │
│  │  MySQL   │  │  Redis   │  │ Nacos   │  │SkyWalking│           │
│  │ 集群     │  │ 集群     │  │ 集群     │  │ 集群     │            │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘            │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 网络架构设计

```
                            Internet
                                │
                      ┌─────────┴─────────┐
                      │   边界防火墙       │
                      └─────────┬─────────┘
                                │
                      ┌─────────┴─────────┐
                      │   CDN/WAF集群     │
                      └─────────┬─────────┘
                                │
                      ┌─────────┴─────────┐
                      │   负载均衡器       │
                      │   (F5/Nginx)     │
                      └─────────┬─────────┘
                                │
            ┌───────────────────┼───────────────────┐
            │                   │                   │
    ┌───────┴────────┐  ┌──────┴──────┐  ┌──────┴──────┐
    │   DMZ区域       │  │   应用区域    │  │   数据区域    │
    │                │  │              │  │              │
    │ ┌─────────────┐ │  │ ┌──────────┐ │  │ ┌──────────┐ │
    │ │   API网关     │ │  │ │ 管理服务   │ │  │ │  数据库   │ │
    │ │    集群      │ │  │ │   集群     │ │  │ │  集群     │ │
    │ └─────────────┘ │  │ └──────────┘ │  │ └──────────┘ │
    │                │  │              │  │              │
    │ ┌─────────────┐ │  │ ┌──────────┐ │  │ ┌──────────┐ │
    │ │  监控告警     │ │  │ │ 业务服务   │ │  │ │ 缓存集群  │ │
    │ │   系统      │ │  │ │   集群     │ │  │ │          │ │
    │ └─────────────┘ │  │ └──────────┘ │  │ └──────────┘ │
    └────────────────┘  └──────────────┘  └──────────────┘
```

## 三、核心模块设计

### 3.1 API网关核心模块

#### 3.1.1 网关服务架构
```java
@Component
public class ApiGatewayConfiguration {
    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
            .route("api_route", r -> r
                .path("/api/**")
                .filters(f -> f
                    .stripPrefix(1)  // 路径重写
                    .requestRateLimiter(config -> config
                        .setRateLimiter(redisRateLimiter())
                        .setKeyResolver(ipKeyResolver())
                    )
                    .circuitBreaker(config -> config
                        .setName("myCircuitBreaker")
                        .setFallbackUri("forward:/fallback")
                    )
                )
                .uri("lb://api-service")
            )
            .build();
    }
}
```

#### 3.1.2 路由引擎设计
```java
public interface RouteEngine {
    /**
     * 路由匹配
     */
    RouteResult match(RouteRequest request);
    
    /**
     * 负载均衡
     */
    ServiceInstance loadBalance(RouteResult route, String serviceId);
    
    /**
     * 健康检查
     */
    boolean healthCheck(ServiceInstance instance);
}

@Component
public class DefaultRouteEngine implements RouteEngine {
    
    private final Map<String, RouteRule> routeRules;
    private final LoadBalancer loadBalancer;
    private final HealthChecker healthChecker;
    
    @Override
    public RouteResult match(RouteRequest request) {
        for (RouteRule rule : routeRules.values()) {
            if (rule.matches(request)) {
                return rule.execute(request);
            }
        }
        return RouteResult.notFound();
    }
}
```

### 3.2 认证授权模块

#### 3.2.1 认证流程设计
```java
@Component
public class AuthenticationManager {
    
    public AuthenticationResult authenticate(AuthenticationRequest request) {
        // 多策略认证
        if (isJwtToken(request.getToken())) {
            return authenticateWithJwt(request);
        } else if (isApiKey(request.getHeaders())) {
            return authenticateWithApiKey(request);
        } else if (isOAuth2(request.getHeaders())) {
            return authenticateWithOAuth2(request);
        }
        return AuthenticationResult.failure("认证失败");
    }
    
    private AuthenticationResult authenticateWithJwt(AuthenticationRequest request) {
        // JWT认证逻辑
        try {
            JwtParser parser = Jwts.parserBuilder()
                .setSigningKey(jwtSecretKey)
                .build();
            Claims claims = parser.parseClaimsJws(request.getToken())
                .getBody();
            return AuthenticationResult.success(parseUserInfo(claims));
        } catch (Exception e) {
            return AuthenticationResult.failure("JWT认证失败");
        }
    }
}
```

#### 3.2.2 权限控制模型
```java
// RBAC权限模型
@Entity
public class Role {
    private Long id;
    private String roleName;
    private String description;
    private Set<Permission> permissions;
}

// 资源权限
@Entity
public class Permission {
    private Long id;
    private String resource; // 资源标识
    private String action;   // 操作类型
    private Set<Role> roles;
}

@Component
public class PermissionChecker {
    
    public boolean checkPermission(String userId, String resource, String action) {
        Set<String> userPermissions = getUserPermissions(userId);
        String permissionKey = resource + ":" + action;
        return userPermissions.contains(permissionKey);
    }
    
    private Set<String> getUserPermissions(String userId) {
        // 查询用户权限集合
        return permissionRepository.findUserPermissions(userId);
    }
}
```

### 3.3 流量控制模块

#### 3.3.1 限流策略设计
```java
@Component
public class RateLimiter {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    public boolean isAllowed(String key, int limit, long window) {
        String luaScript = 
            "local key = KEYS[1] " +
            "local limit = tonumber(ARGV[1]) " +
            "local window = tonumber(ARGV[2]) " +
            "local current = redis.call('GET', key) " +
            "if current == false then " +
            "  redis.call('SETEX', key, window, 1) " +
            "  return 1 " +
            "else " +
            "  current = tonumber(current) " +
            "  if current >= limit then " +
            "    return 0 " +
            "  else " +
            "    return redis.call('INCR', key) " +
            "  end " +
            "end";
        
        DefaultRedisScript<Long> script = new DefaultRedisScript<>(luaScript, Long.class);
        Long result = redisTemplate.execute(script, Collections.singletonList(key), 
            String.valueOf(limit), String.valueOf(window));
        return result == 1;
    }
}
```

#### 3.3.2 熔断降级机制
```java
@Component
public class CircuitBreaker {
    
    private final Map<String, CircuitBreakerState> circuitBreakers = new ConcurrentHashMap<>();
    
    public <T> T execute(String serviceId, Supplier<T> supplier) {
        CircuitBreakerState state = getCircuitBreaker(serviceId);
        
        if (state == CircuitBreakerState.OPEN) {
            if (System.currentTimeMillis() > state.getNextAttemptTime()) {
                state = CircuitBreakerState.HALF_OPEN;
                circuitBreakers.put(serviceId, state);
            } else {
                return executeFallback(supplier);
            }
        }
        
        try {
            T result = supplier.get();
            onSuccess(serviceId);
            return result;
        } catch (Exception e) {
            onFailure(serviceId);
            return executeFallback(supplier);
        }
    }
}
```

### 3.4 监控告警模块

#### 3.4.1 指标收集
```java
@Component
public class MetricsCollector {
    
    private final MeterRegistry meterRegistry;
    
    public void recordApiCall(String method, String path, long responseTime, boolean success) {
        Counter.builder("api_calls_total")
            .description("Total API calls")
            .tags("method", method, "path", path, "success", String.valueOf(success))
            .register(meterRegistry)
            .increment();
            
        Timer.Sample sample = Timer.start(meterRegistry);
        Timer.builder("api_duration")
            .description("API response time")
            .tags("method", method, "path", path)
            .register(meterRegistry)
            .record(responseTime, TimeUnit.MILLISECONDS);
    }
    
    public void recordSystemMetrics(SystemMetrics metrics) {
        Gauge.builder("cpu_usage")
            .description("CPU usage percentage")
            .register(meterRegistry, metrics, SystemMetrics::getCpuUsage);
            
        Gauge.builder("memory_usage")
            .description("Memory usage percentage")
            .register(meterRegistry, metrics, SystemMetrics::getMemoryUsage);
    }
}
```

#### 3.4.2 告警管理
```java
@Service
public class AlertManager {
    
    @Async
    public void handleAlert(Alert alert) {
        // 告警分级处理
        switch (alert.getSeverity()) {
            case CRITICAL:
                sendCriticalAlert(alert);
                break;
            case WARNING:
                sendWarningAlert(alert);
                break;
            case INFO:
                sendInfoAlert(alert);
                break;
        }
        
        // 记录告警历史
        alertRepository.save(alert);
    }
    
    private void sendCriticalAlert(Alert alert) {
        // 多渠道通知
        sendSms(alert);
        sendEmail(alert);
        sendWebhooks(alert);
        sendDingTalk(alert);
    }
}
```

## 四、数据库设计

### 4.1 核心数据表设计

#### 4.1.1 API管理表
```sql
-- API定义表
CREATE TABLE api_definition (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    api_name VARCHAR(255) NOT NULL COMMENT 'API名称',
    api_path VARCHAR(500) NOT NULL COMMENT 'API路径',
    method VARCHAR(10) NOT NULL COMMENT 'HTTP方法',
    version VARCHAR(50) NOT NULL COMMENT 'API版本',
    description TEXT COMMENT 'API描述',
    tenant_id BIGINT NOT NULL COMMENT '租户ID',
    status TINYINT DEFAULT 1 COMMENT '状态：1-启用，0-禁用',
    created_by VARCHAR(100) NOT NULL COMMENT '创建人',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_api_path (api_path),
    INDEX idx_tenant_version (tenant_id, version),
    INDEX idx_status (status)
);

-- API版本管理表
CREATE TABLE api_version (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    api_id BIGINT NOT NULL COMMENT 'API定义ID',
    version VARCHAR(50) NOT NULL COMMENT '版本号',
    status TINYINT DEFAULT 1 COMMENT '状态：1-活跃，0-停用',
    gray_weight INT DEFAULT 0 COMMENT '灰度权重(0-100)',
    deployment_time DATETIME COMMENT '发布时间',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (api_id) REFERENCES api_definition(id),
    INDEX idx_api_version (api_id, version)
);
```

#### 4.1.2 路由规则表
```sql
-- 路由规则表
CREATE TABLE route_rule (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    rule_name VARCHAR(255) NOT NULL COMMENT '规则名称',
    route_type TINYINT NOT NULL COMMENT '路由类型：1-路径，2-域名，3-请求头',
    match_pattern VARCHAR(1000) NOT NULL COMMENT '匹配模式',
    target_service VARCHAR(255) NOT NULL COMMENT '目标服务',
    load_balance VARCHAR(50) DEFAULT 'round_robin' COMMENT '负载均衡策略',
    priority INT DEFAULT 100 COMMENT '优先级，数字越小优先级越高',
    enabled TINYINT DEFAULT 1 COMMENT '是否启用',
    tenant_id BIGINT NOT NULL COMMENT '租户ID',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_route_type (route_type),
    INDEX idx_priority (priority),
    INDEX idx_tenant_enabled (tenant_id, enabled)
);
```

#### 4.1.3 认证授权表
```sql
-- 用户表
CREATE TABLE sys_user (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(100) NOT NULL UNIQUE COMMENT '用户名',
    password VARCHAR(255) NOT NULL COMMENT '密码(加密)',
    email VARCHAR(255) COMMENT '邮箱',
    mobile VARCHAR(20) COMMENT '手机号',
    status TINYINT DEFAULT 1 COMMENT '状态：1-正常，0-禁用',
    tenant_id BIGINT NOT NULL COMMENT '租户ID',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_username (username),
    INDEX idx_tenant (tenant_id)
);

-- 角色表
CREATE TABLE sys_role (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    role_name VARCHAR(100) NOT NULL COMMENT '角色名称',
    role_code VARCHAR(100) NOT NULL UNIQUE COMMENT '角色编码',
    description TEXT COMMENT '角色描述',
    tenant_id BIGINT NOT NULL COMMENT '租户ID',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_role_code (role_code),
    INDEX idx_tenant (tenant_id)
);

-- 权限表
CREATE TABLE sys_permission (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    permission_name VARCHAR(100) NOT NULL COMMENT '权限名称',
    permission_code VARCHAR(100) NOT NULL UNIQUE COMMENT '权限编码',
    resource VARCHAR(255) NOT NULL COMMENT '资源标识',
    action VARCHAR(50) NOT NULL COMMENT '操作类型',
    description TEXT COMMENT '权限描述',
    tenant_id BIGINT NOT NULL COMMENT '租户ID',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_resource_action (resource, action),
    INDEX idx_tenant (tenant_id)
);

-- API Key表
CREATE TABLE api_key (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    key_name VARCHAR(255) NOT NULL COMMENT 'Key名称',
    api_key VARCHAR(255) NOT NULL UNIQUE COMMENT 'API Key值',
    secret_key VARCHAR(255) NOT NULL COMMENT 'Secret Key值',
    status TINYINT DEFAULT 1 COMMENT '状态：1-启用，0-禁用',
    rate_limit INT DEFAULT 1000 COMMENT '速率限制',
    expires_time DATETIME COMMENT '过期时间',
    tenant_id BIGINT NOT NULL COMMENT '租户ID',
    created_by BIGINT NOT NULL COMMENT '创建人ID',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_api_key (api_key),
    INDEX idx_tenant (tenant_id)
);
```

#### 4.1.4 监控日志表
```sql
-- API调用日志表
CREATE TABLE api_call_log (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    trace_id VARCHAR(100) NOT NULL COMMENT '链路追踪ID',
    api_path VARCHAR(500) NOT NULL COMMENT 'API路径',
    method VARCHAR(10) NOT NULL COMMENT 'HTTP方法',
    client_ip VARCHAR(50) COMMENT '客户端IP',
    request_time DATETIME NOT NULL COMMENT '请求时间',
    response_time BIGINT COMMENT '响应时间(ms)',
    status_code INT COMMENT '响应状态码',
    success TINYINT COMMENT '是否成功',
    error_message TEXT COMMENT '错误信息',
    request_size INT COMMENT '请求大小',
    response_size INT COMMENT '响应大小',
    user_agent TEXT COMMENT '用户代理',
    tenant_id BIGINT NOT NULL COMMENT '租户ID',
    INDEX idx_trace_id (trace_id),
    INDEX idx_request_time (request_time),
    INDEX idx_tenant_time (tenant_id, request_time),
    INDEX idx_api_path (api_path)
);

-- 系统监控指标表
CREATE TABLE system_metrics (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    metric_name VARCHAR(100) NOT NULL COMMENT '指标名称',
    metric_value DECIMAL(15,4) NOT NULL COMMENT '指标值',
    tags JSON COMMENT '标签信息',
    timestamp DATETIME NOT NULL COMMENT '时间戳',
    INDEX idx_metric_time (metric_name, timestamp),
    INDEX idx_timestamp (timestamp)
);
```

### 4.2 缓存设计

#### 4.2.1 Redis缓存策略
```java
@Component
public class CacheManager {
    
    // API路由缓存
    private static final String ROUTE_CACHE = "route:cache";
    
    // 用户认证缓存
    private static final String AUTH_CACHE = "auth:cache";
    
    // API Key缓存
    private static final String API_KEY_CACHE = "api:key";
    
    // 限流计数器缓存
    private static final String RATE_LIMIT_CACHE = "rate:limit";
    
    @Cacheable(value = ROUTE_CACHE, key = "#path")
    public RouteConfig getRouteConfig(String path) {
        return routeConfigRepository.findByPath(path);
    }
    
    @Cacheable(value = AUTH_CACHE, key = "#token")
    public UserInfo validateToken(String token) {
        return jwtService.validateToken(token);
    }
}
```

## 五、安全架构设计

### 5.1 安全防护体系

#### 5.1.1 多层安全架构
```
┌─────────────────────────────────────────────────────────────────┐
│                        安全防护层                                │
│                                                                 │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐            │
│  │   网络安全   │  │   应用安全   │  │   数据安全   │            │
│  │            │  │            │  │            │            │
│  │ 防火墙/IPS  │  │ WAF/安全扫描│  │ 加密/脱敏    │            │
│  │ DDoS防护   │  │ 身份认证    │  │ 访问控制    │            │
│  │ 黑白名单    │  │ 权限校验    │  │ 审计日志    │            │
│  └─────────────┘  └─────────────┘  └─────────────┘            │
└─────────────────────────────────────────────────────────────────┘
```

#### 5.1.2 数据加密方案
```java
@Component
public class DataEncryptionService {
    
    // AES对称加密
    public String encrypt(String data, String key) {
        try {
            KeySpec keySpec = new SecretKeySpec(key.getBytes(), "AES");
            Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
            cipher.init(Cipher.ENCRYPT_MODE, keySpec);
            byte[] encryptedData = cipher.doFinal(data.getBytes());
            return Base64.getEncoder().encodeToString(encryptedData);
        } catch (Exception e) {
            throw new RuntimeException("数据加密失败", e);
        }
    }
    
    // RSA非对称加密
    public String encryptWithRSA(String data, String publicKey) {
        try {
            PublicKey pubKey = KeyFactory.getInstance("RSA")
                .generatePublic(new X509EncodedKeySpec(Base64.getDecoder().decode(publicKey)));
            Cipher cipher = Cipher.getInstance("RSA");
            cipher.init(Cipher.ENCRYPT_MODE, pubKey);
            return Base64.getEncoder().encodeToString(cipher.doFinal(data.getBytes()));
        } catch (Exception e) {
            throw new RuntimeException("RSA加密失败", e);
        }
    }
    
    // 数据脱敏
    public String maskSensitiveData(String data, DataType type) {
        switch (type) {
            case MOBILE_PHONE:
                return data.replaceAll("(\\d{3})\\d{4}(\\d{4})", "$1****$2");
            case ID_CARD:
                return data.replaceAll("(\\d{6})\\d{8}(\\d{4})", "$1********$2");
            case BANK_CARD:
                return data.replaceAll("(\\d{4})\\d+(\\d{4})", "$1****$2");
            default:
                return data;
        }
    }
}
```

### 5.2 WAF防护规则
```java
@Component
public class WafRuleEngine {
    
    private final List<WafRule> wafRules = Arrays.asList(
        // SQL注入防护
        new WafRule("sql_injection", "防止SQL注入攻击", 
            Arrays.asList("(?i)(union|select|insert|delete|update|drop|exec)", 
                         "(?i)(script|javascript|vbscript|onload|onerror)")),
        
        // XSS防护
        new WafRule("xss_protection", "防止跨站脚本攻击",
            Arrays.asList("(?i)(<script|</script>|javascript:|vbscript:)")),
        
        // 请求频率限制
        new WafRule("frequency_limit", "请求频率限制",
            Collections.singletonList("请求频率超过限制")),
        
        // 恶意文件上传防护
        new WafRule("file_upload", "防止恶意文件上传",
            Arrays.asList("\\.exe$", "\\.bat$", "\\.sh$", "\\.php$"))
    );
    
    public WafResult checkRequest(HttpServletRequest request) {
        String content = request.getRequestURI() + 
                        Optional.ofNullable(request.getQueryString()).orElse("") +
                        Optional.ofNullable(request.getParameterMap().toString()).orElse("");
        
        for (WafRule rule : wafRules) {
            for (String pattern : rule.getPatterns()) {
                if (content.matches(pattern)) {
                    return WafResult.blocked(rule.getName(), rule.getDescription());
                }
            }
        }
        return WafResult.allowed();
    }
}
```

## 六、性能优化设计

### 6.1 性能优化策略

#### 6.1.1 异步处理架构
```java
@Component
public class AsyncProcessor {
    
    @Async("taskExecutor")
    public CompletableFuture<Void> processRequestAsync(RequestContext context) {
        // 异步处理请求
        return CompletableFuture.runAsync(() -> {
            // 记录日志
            logService.asyncLog(context);
            
            // 发送监控数据
            metricsService.asyncMetrics(context);
            
            // 触发告警
            alertService.asyncAlert(context);
        });
    }
    
    @Async("taskExecutor")
    public CompletableFuture<Response> forwardToBackendAsync(RequestContext context) {
        // 异步转发请求到后端服务
        return CompletableFuture.supplyAsync(() -> {
            try {
                return httpClient.forward(context);
            } catch (Exception e) {
                logger.error("后端服务调用失败", e);
                throw new RuntimeException(e);
            }
        });
    }
}
```

#### 6.1.2 连接池优化
```java
@Configuration
public class HttpClientConfig {
    
    @Bean
    public CloseableHttpClient httpClient() {
        PoolingHttpClientConnectionManager connectionManager = 
            new PoolingHttpClientConnectionManager();
        connectionManager.setMaxTotal(200); // 最大连接数
        connectionManager.setDefaultMaxPerRoute(50); // 每个路由最大连接数
        connectionManager.setValidateAfterInactivity(5000); // 空闲连接检查间隔
        
        RequestConfig requestConfig = RequestConfig.custom()
            .setConnectTimeout(5000) // 连接超时
            .setSocketTimeout(10000) // 读取超时
            .setConnectionRequestTimeout(2000) // 获取连接超时
            .build();
            
        return HttpClients.custom()
            .setConnectionManager(connectionManager)
            .setDefaultRequestConfig(requestConfig)
            .setUserAgent("API-Gateway/1.0")
            .build();
    }
}
```

### 6.2 缓存优化

#### 6.2.1 多级缓存架构
```java
@Component
public class MultiLevelCache {
    
    @Autowired
    private CaffeineCache localCache;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    public <T> T get(String key, Class<T> type) {
        // L1: 本地缓存
        T localValue = localCache.get(key, type);
        if (localValue != null) {
            return localValue;
        }
        
        // L2: Redis缓存
        Object redisValue = redisTemplate.opsForValue().get(key);
        if (redisValue != null) {
            // 回写到本地缓存
            localCache.put(key, redisValue);
            return (T) redisValue;
        }
        
        return null;
    }
    
    public void put(String key, Object value, long expireTime) {
        // 写入本地缓存
        localCache.put(key, value);
        
        // 写入Redis缓存
        redisTemplate.opsForValue().set(key, value, expireTime, TimeUnit.SECONDS);
    }
}
```

## 七、监控可观测性设计

### 7.1 监控指标体系

#### 7.1.1 核心监控指标
```java
@Component
public class ApiGatewayMetrics {
    
    // API调用总量
    private final Counter apiCallsTotal;
    
    // API响应时间
    private final Timer apiDuration;
    
    // API成功率
    private final Gauge successRate;
    
    // 当前并发数
    private final Gauge concurrentRequests;
    
    // 限流触发次数
    private final Counter rateLimitTriggers;
    
    // 熔断器状态
    private final Gauge circuitBreakerState;
    
    public ApiGatewayMetrics(MeterRegistry registry) {
        this.apiCallsTotal = Counter.builder("api_calls_total")
            .description("Total API calls")
            .register(registry);
            
        this.apiDuration = Timer.builder("api_duration")
            .description("API response time")
            .register(registry);
            
        this.successRate = Gauge.builder("api_success_rate")
            .description("API success rate")
            .register(registry, this, ApiGatewayMetrics::calculateSuccessRate);
    }
}
```

#### 7.1.2 链路追踪集成
```java
@Component
public class TracingInterceptor implements HandlerInterceptor {
    
    @Autowired
    private Tracer tracer;
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, 
                           Object handler) {
        // 生成traceId
        String traceId = UUID.randomUUID().toString();
        MDC.put("traceId", traceId);
        
        // 开始span
        Span span = tracer.nextSpan()
            .name("api_gateway_request")
            .tag("http.method", request.getMethod())
            .tag("http.url", request.getRequestURI())
            .tag("client.ip", getClientIp(request))
            .start();
            
        tracer.withSpanInScope(span);
        
        return true;
    }
    
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response,
                               Object handler, Exception ex) {
        Span span = tracer.currentSpan();
        if (span != null) {
            span.tag("http.status_code", String.valueOf(response.getStatus()));
            if (ex != null) {
                span.tag("error", ex.getMessage());
            }
            span.finish();
        }
        
        MDC.remove("traceId");
    }
}
```

---

**文档版本：V1.0**  
**创建日期：2024年**  
**最后更新：2024年**  
**文档状态：设计阶段**